use mirrord_config_derive::MirrordConfig;
use schemars::JsonSchema;

use super::{FsModeConfig, FsUserConfig};
use crate::{
    config::{from_env::FromEnv, source::MirrordConfigSource, ConfigError},
    util::{MirrordToggleableConfig, VecOrSingle},
};

// TODO(alex): We could turn this derive macro (`MirrordConfig`) into an attribute version, which
// would allow us to "capture" the `derive` statement, making it possible to implement the same for
// whatever is generated by `map_to`.

#[derive(MirrordConfig, Default, Clone, PartialEq, Eq, Debug)]
#[config(
    map_to = "AdvancedFsUserConfig",
    derive = "PartialEq,Eq,JsonSchema",
    generator = "FsUserConfig"
)]
pub struct FsConfig {
    /// ### feature.fs.mode {#feature-fs-mode}
    ///
    /// Configuration for enabling read-only or read-write file operations.
    ///
    /// These options are overriden by user specified overrides and mirrord default overrides.
    ///
    /// If you set [`"localwithoverrides"`](#feature-fs-mode-localwithoverrides) then some files
    /// can be read/write remotely based on our default/user specified.
    /// Default option for general file configuration.
    ///
    /// The accepted values are: `"local"`, `"localwithoverrides`, `"read"`, or `"write`.
    #[config(nested)]
    pub mode: FsModeConfig,

    /// ### feature.fs.read_write {#feature-fs-read_write}
    ///
    /// Specify file path patterns that if matched will be read and written to the remote.
    #[config(env = "MIRRORD_FILE_READ_WRITE_PATTERN")]
    pub read_write: Option<VecOrSingle<String>>,

    /// ### feature.fs.read_only {#feature-fs-read_only}
    ///
    /// Specify file path patterns that if matched will be read from the remote.
    /// if file matching the pattern is opened for writing or read/write it will be opened locally.
    pub read_only: Option<VecOrSingle<String>>,

    /// ### feature.fs.local {#feature-fs-local}
    ///
    /// Specify file path patterns that if matched will be opened locally.
    #[config(env = "MIRRORD_FILE_LOCAL_PATTERN")]
    pub local: Option<VecOrSingle<String>>,
}

impl MirrordToggleableConfig for AdvancedFsUserConfig {
    fn disabled_config() -> Result<Self::Generated, ConfigError> {
        let mode = FsModeConfig::disabled_config()?;
        let read_write = FromEnv::new("MIRRORD_FILE_READ_WRITE_PATTERN")
            .source_value()
            .transpose()?;
        let read_only = FromEnv::new("MIRRORD_FILE_READ_ONLY_PATTERN")
            .source_value()
            .transpose()?;
        let local = FromEnv::new("MIRRORD_FILE_LOCAL_PATTERN")
            .source_value()
            .transpose()?;

        Ok(Self::Generated {
            mode,
            read_write,
            read_only,
            local,
        })
    }
}

impl FsConfig {
    pub fn is_read(&self) -> bool {
        self.mode.is_read()
    }

    pub fn is_write(&self) -> bool {
        self.mode.is_write()
    }

    /// Checks if fs operations are active
    pub fn is_active(&self) -> bool {
        !matches!(self.mode, FsModeConfig::Local)
    }
}

#[cfg(test)]
mod tests {
    use rstest::rstest;

    use super::*;
    use crate::config::MirrordConfig;

    #[rstest]
    fn advanced_fs_config_default() {
        let expect = FsConfig {
            mode: FsModeConfig::Read,
            ..Default::default()
        };

        let fs_config = AdvancedFsUserConfig::default().generate_config().unwrap();

        assert_eq!(fs_config, expect);
    }
}
