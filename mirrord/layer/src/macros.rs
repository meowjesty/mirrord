//! Macros used by mirrord-layer (mostly for hooking [`libc`] functions).
//!
//! ## Macros
//!
//! - [`replace`]
//!
//! Replaces a [`libc`] function with a hook.
//!
//! - [`replace_symbol`]
//! - [`hook_symbol`]
//! - [`graceful_exit`]

/// Replaces the `$func` [`libc`] function, with the equivalent hook `$detour_function`, by calling
/// [`hook_export_or_any`].
///
/// ## Parameters
///
/// - `hook_manager`: a valid [`HookManager`](crate::hooks::HookManager) instance that is used to
///   replace the [`libc`] function;
///
/// - `func`: the function we want to replace;
///
/// - `detour_function`: one of our detour functions;
///
/// - `detour_type`: the type alias that was generated by [`hook_fn`](link) for this function type;
///
/// - `hook_fn`: stores the original function pointer as a [`HookFn`](crate::detour::HookFn) that is
///   created by [`hook_fn`](link).
#[macro_export]
macro_rules! replace {
    ($hook_manager:expr, $func:expr, $detour_function:expr, $detour_type:ty, $hook_fn:expr) => {{
        let intercept = |hook_manager: &mut $crate::hooks::HookManager,
                         symbol_name,
                         detour: $detour_type|
         -> $crate::error::Result<$detour_type> {
            let replaced =
                hook_manager.hook_export_or_any(symbol_name, detour as *mut libc::c_void)?;
            let original_fn: $detour_type = std::mem::transmute(replaced);

            tracing::trace!("hooked {symbol_name:?}");
            Ok(original_fn)
        };

        let _ = intercept($hook_manager, $func, $detour_function)
            .and_then(|hooked| Ok($hook_fn.set(hooked).unwrap()));
    }};
}

#[macro_export]
macro_rules! replace_symbol {
    ($hook_manager:expr, $func:expr, $detour_function:expr, $detour_type:ty, $hook_fn:expr) => {{
        let intercept = |hook_manager: &mut $crate::hooks::HookManager,
                         symbol_name,
                         detour: $detour_type|
         -> $crate::error::Result<$detour_type> {
            let replaced =
                hook_manager.hook_symbol_main_module(symbol_name, detour as *mut libc::c_void)?;
            let original_fn: $detour_type = std::mem::transmute(replaced);

            tracing::trace!("hooked {symbol_name:?}");
            Ok(original_fn)
        };

        let _ = intercept($hook_manager, $func, $detour_function)
            .and_then(|hooked| Ok($hook_fn.set(hooked).unwrap()));
    }};
}

#[cfg(all(target_os = "linux", not(target_arch = "aarch64")))]
macro_rules! hook_symbol {
    ($hook_manager:expr, $func:expr, $detour_name:expr) => {
        match $hook_manager.hook_symbol_main_module($func, $detour_name as *mut libc::c_void) {
            Ok(_) => {
                trace!("hooked {:?} in main module", $func);
            }
            Err(err) => {
                trace!("hook {:?} in main module failed with err {err:?}", $func);
            }
        }
    };
}

#[macro_export]
macro_rules! graceful_exit {
    ($($arg:tt)+) => {{
        eprintln!($($arg)+);
        graceful_exit!()
    }};
    () => {{
        nix::sys::signal::kill(
            nix::unistd::Pid::from_raw(std::process::id() as i32),
            nix::sys::signal::Signal::SIGTERM,
        )
        .expect("unable to graceful exit");
        panic!()
    }};
}

#[cfg(all(target_os = "linux", not(target_arch = "aarch64")))]
pub(crate) use hook_symbol;
