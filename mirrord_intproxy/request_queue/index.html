<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A request fifo used by the internal proxy to match agent responses with layer requests."><title>mirrord_intproxy::request_queue - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-47e7ab555ef2818a.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mirrord_intproxy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (e3abbd499 2023-09-06)" data-channel="nightly" data-search-js="search-5d3eaacf19ebf04f.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-f194925aa375ae96.css" data-theme-dark-css="dark-1dd4d1ce031e15de.css" data-theme-ayu-css="ayu-49e58d069f567085.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-f194925aa375ae96.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1dd4d1ce031e15de.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../mirrord_intproxy/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../mirrord_intproxy/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module request_queue</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">mirrord_intproxy</a>::<wbr><a class="mod" href="#">request_queue</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/mirrord_intproxy/request_queue.rs.html#1-56">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A request fifo used by the internal proxy to match agent responses with layer requests.</p>
<p>The layer annotates each message with unique <a href="../../mirrord_intproxy_protocol/type.MessageId.html" title="type mirrord_intproxy_protocol::MessageId"><code>MessageId</code></a>,
which allows it to match responses from the internal proxy with awaiting requests.
However, the agent does not use any mechanism like this.
Instead, its components (e.g. file manager) handle requests of the same kind (e.g.
<a href="../../mirrord_protocol/codec/enum.FileRequest.html" title="enum mirrord_protocol::codec::FileRequest"><code>FileRequest</code></a>s) sequentially. The internal proxy relies
on this behavior and stores <a href="../../mirrord_intproxy_protocol/type.MessageId.html" title="type mirrord_intproxy_protocol::MessageId"><code>MessageId</code></a>s of layer’s requests in multiple queues. Upon
receiving a response from the agent, correct <a href="../../mirrord_intproxy_protocol/type.MessageId.html" title="type mirrord_intproxy_protocol::MessageId"><code>MessageId</code></a> is taken from the right queue.</p>
<p>Additionaly, single internal proxy handles multiple layer
instances (coming from forks). This fifo stores their <a href="../../mirrord_intproxy_protocol/struct.LayerId.html" title="struct mirrord_intproxy_protocol::LayerId"><code>LayerId</code></a>s as well.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.RequestQueue.html" title="struct mirrord_intproxy::request_queue::RequestQueue">RequestQueue</a></div><div class="desc docblock-short">A queue used to match agent responses with layer requests.
A single queue can be used for multiple types of requests only if the agent preserves order
between them.</div></li><li><div class="item-name"><a class="struct" href="struct.RequestQueueEmpty.html" title="struct mirrord_intproxy::request_queue::RequestQueueEmpty">RequestQueueEmpty</a></div><div class="desc docblock-short">Erorr returned when the proxy attempts to retrieve <a href="../../mirrord_intproxy_protocol/type.MessageId.html" title="type mirrord_intproxy_protocol::MessageId"><code>MessageId</code></a> and <a href="../../mirrord_intproxy_protocol/struct.LayerId.html" title="struct mirrord_intproxy_protocol::LayerId"><code>LayerId</code></a> of a request
corresponding to a response received from the agent, but the <a href="struct.RequestQueue.html" title="struct mirrord_intproxy::request_queue::RequestQueue"><code>RequestQueue</code></a> is empty. This
error should never happen.</div></li></ul></section></div></main></body></html>